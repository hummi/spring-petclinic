package sandbox;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.xml.sax.SAXException;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Unmarshaller;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.*;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;
import java.io.*;
import java.net.URISyntaxException;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

// For write operation

/**
 * Created by dhummel on 22.12.2015.
 */
public class LoadModel {
    private static final String NAMESPACE = "xmlns:";
    // Global value so it can be ref'd by the tree-adapter
    static Document document;

    public static final String NS_XMI_20131001 = "http://www.omg.org/spec/XMI/20131001";
    public static final String NS_UML2_5_0_0_UML = "http://www.eclipse.org/uml2/5.0.0/UML";
    public static final String EXTRACTOR_ECLIPSE_500_UML2_XSL = "./data/eclipse_500_uml2.xsl";
    public static final String EXTRACTOR_ECLIPSE_500_UML2_KEY = "umlxmi";
    private static final Map<String, Function<Collection<String>,File>> EXTRACTORS =
            new LinkedHashMap<String, Function<Collection<String>,File>>() {
        {
            put(EXTRACTOR_ECLIPSE_500_UML2_KEY, (namespaces) -> {
                if (namespaces.containsAll(Arrays.asList(NS_XMI_20131001, NS_UML2_5_0_0_UML))) {
                    try {
                        return new File(LoadModel.class.getClassLoader().getResource(EXTRACTOR_ECLIPSE_500_UML2_XSL).toURI());
                    } catch (URISyntaxException e) {
                        throw new RuntimeException("could not load extractor", e);
                    }
                }

                throw new RuntimeException("could not found extractor");
            });
        }
    };

    public static void main(String[] argv) throws JAXBException {
        argv = new String[] {".\\src\\tool\\resources\\test\\model.uml"};

        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();

//        factory.setNamespaceAware(true);
//        factory.setValidating(true);
        try {
            File datafile = new File(argv[0]);

            DocumentBuilder builder = factory.newDocumentBuilder();
            document = builder.parse(datafile);

            Element documentElement = document.getDocumentElement();

            File modelExtractor = determineExtractor(documentElement);

            // Use a Transformer for output
            TransformerFactory tFactory = TransformerFactory.newInstance();
            StreamSource stylesource = new StreamSource(modelExtractor);
            Transformer transformer = tFactory.newTransformer(stylesource);

            transformer.setOutputProperty(OutputKeys.STANDALONE, "yes");
            transformer.setOutputProperty(OutputKeys.INDENT, "yes");

            DOMSource source = new DOMSource(document);
            StreamResult result = new StreamResult(System.out);
            transformer.transform(source, result);

            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            StreamResult resultAsStream = new StreamResult(outputStream);
            transformer.transform(source, resultAsStream);

            final InputStream in = new ByteArrayInputStream(outputStream.toByteArray());

            JAXBContext jc = JAXBContext.newInstance(model.System.class);

            Unmarshaller unmarshaller = jc.createUnmarshaller();
            model.System sys = (model.System) unmarshaller.unmarshal(in);
            System.out.println(sys);
        } catch (TransformerConfigurationException tce) {
            // Error generated by the parser
            System.out.println("\n** Transformer Factory error");
            System.out.println("   " + tce.getMessage());

            // Use the contained exception, if any
            Throwable x = tce;

            if (tce.getException() != null) {
                x = tce.getException();
            }

            x.printStackTrace();
        } catch (TransformerException te) {
            // Error generated by the parser
            System.out.println("\n** Transformation error");
            System.out.println("   " + te.getMessage());

            // Use the contained exception, if any
            Throwable x = te;

            if (te.getException() != null) {
                x = te.getException();
            }

            x.printStackTrace();
        } catch (SAXException sxe) {
            // Error generated by this application
            // (or a parser-initialization error)
            Exception x = sxe;

            if (sxe.getException() != null) {
                x = sxe.getException();
            }

            x.printStackTrace();
        } catch (ParserConfigurationException pce) {
            // Parser with specified options can't be built
            pce.printStackTrace();
        } catch (IOException ioe) {
            // I/O error
            ioe.printStackTrace();
        }
    } // main

    private static File determineExtractor(Element documentElement) {
        NamedNodeMap attributes = documentElement.getAttributes();
        Map<String,String> xmlns = new LinkedHashMap<String, String>(3);
        for (int i = 0; i < attributes.getLength(); i++) {
            Node node = attributes.item(i);
            node.normalize();
            String nodeName = node.getNodeName().toLowerCase();
            if (nodeName.startsWith(NAMESPACE)) {
                xmlns.put(nodeName.substring(NAMESPACE.length()), node.getNodeValue());
            }
        }

        String key = xmlns.entrySet().stream()
                .sorted(Comparator.comparing(Map.Entry::getKey))
                .map(Map.Entry::getKey)
                .collect(Collectors.toList())
                .stream()
                .reduce("",(a,b) -> a+b);

        return EXTRACTORS.get(key).apply(xmlns.values());
    }
}
